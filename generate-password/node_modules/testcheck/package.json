{
  "_args": [
    [
      {
        "raw": "testcheck@^0.1.0",
        "scope": null,
        "escapedName": "testcheck",
        "name": "testcheck",
        "rawSpec": "^0.1.0",
        "spec": ">=0.1.0 <0.2.0",
        "type": "range"
      },
      "F:\\AStudy\\git-hub\\unit-testing-with-jest\\generate-password\\node_modules\\jasmine-check"
    ]
  ],
  "_from": "testcheck@>=0.1.0 <0.2.0",
  "_id": "testcheck@0.1.4",
  "_inCache": true,
  "_location": "/testcheck",
  "_nodeVersion": "0.10.35",
  "_npmUser": {
    "name": "leebyron",
    "email": "lee@leebyron.com"
  },
  "_npmVersion": "2.2.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "testcheck@^0.1.0",
    "scope": null,
    "escapedName": "testcheck",
    "name": "testcheck",
    "rawSpec": "^0.1.0",
    "spec": ">=0.1.0 <0.2.0",
    "type": "range"
  },
  "_requiredBy": [
    "/jasmine-check"
  ],
  "_resolved": "https://registry.npmjs.org/testcheck/-/testcheck-0.1.4.tgz",
  "_shasum": "90056edd48d11997702616ce6716f197d8190164",
  "_shrinkwrap": null,
  "_spec": "testcheck@^0.1.0",
  "_where": "F:\\AStudy\\git-hub\\unit-testing-with-jest\\generate-password\\node_modules\\jasmine-check",
  "author": {
    "name": "Lee Byron",
    "url": "https://github.com/leebyron"
  },
  "bugs": {
    "url": "https://github.com/leebyron/testcheck-js/issues"
  },
  "dependencies": {},
  "description": "Property testing for JavaScript",
  "devDependencies": {
    "jasmine-node": "^1.14.5"
  },
  "directories": {},
  "dist": {
    "shasum": "90056edd48d11997702616ce6716f197d8190164",
    "tarball": "https://registry.npmjs.org/testcheck/-/testcheck-0.1.4.tgz"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "gitHead": "75aa5a78a315f7755dac6051068ba20ff8c58e3f",
  "homepage": "https://github.com/leebyron/testcheck-js",
  "keywords": [
    "test",
    "unit test",
    "property test",
    "quickcheck",
    "doublecheck",
    "testcheck",
    "generative"
  ],
  "license": "BSD",
  "main": "dist/testcheck.js",
  "maintainers": [
    {
      "name": "leebyron",
      "email": "lee@leebyron.com"
    }
  ],
  "name": "testcheck",
  "optionalDependencies": {},
  "readme": "TestCheck [![Build Status](https://travis-ci.org/leebyron/testcheck-js.svg)](https://travis-ci.org/leebyron/testcheck-js)\n=========\n\nGenerative property testing for JavaScript.\n\n`testcheck-js` is a library for generative testing of program properties,\nala QuickCheck.\n\nBy providing a specification of the JavaScript program in the form of\nproperties, the properties can be tested to remain true for a large number of\nrandomly generated cases. In the case of a test failure, the smallest possible\ntest case is found.\n\n\n### Use Jasmine or Mocha?\n\n`testcheck-js` is a testing utility and not a full test running solution.\n\nIf you\nuse [Jasmine](http://jasmine.github.io/) then check out\n[`jasmine-check`](https://github.com/leebyron/jasmine-check/), a testcheck\nJasmine plugin.\n\nIf you\nuse [Mocha](http://visionmedia.github.io/mocha/) then check out\n[`mocha-check`](https://github.com/leebyron/mocha-check/), a testcheck\nMocha plugin.\n\n\n### Atop the shoulders of giants\n\n`testcheck-js` is based on Clojure's [test.check](https://github.com/clojure/test.check)\nwhich is inspired by Haskell's [QuickCheck](https://hackage.haskell.org/package/QuickCheck).\nIt's made possible by [double-check](https://github.com/cemerick/double-check/),\nthe ClojureScript port of test.check. Many gracious thanks goes to all of the\nbrilliance and hard work enabling this project to exist.\n\n\nGetting started\n---------------\n\nInstall `testcheck` using npm\n\n```shell\nnpm install testcheck\n```\n\nThen require it into your testing environment and start testing.\n\n```javascript\nvar testcheck = require('testcheck');\nvar gen = testcheck.gen;\n\nvar result = testcheck.check(\n  testcheck.property(\n    [gen.int],\n    x => x - x === 0\n  )\n);\n```\n\n### Typescript\n\nIf you write your tests in Typescript, include the testcheck type definitions.\n\n```javascript\n///<reference path='node_modules/testcheck/dist/testcheck.d.ts'/>\nimport testcheck = require('testcheck');\n```\n\n\nAPI\n---\n\nAll API documentation is contained within the type definition file, [testcheck.d.ts](./type-definitions/testcheck.d.ts).\n\n\nDefining properties\n-------------------\n\nA property is simply a function which is expected to always return true, we\nmight also call these properties \"assumptions\" or \"expectations\".\n\nFor example, say we wanted to test the assumption that any number subtracted\nfrom itself will be `0`, we could define this property as:\n\n```javascript\nfunction (x) {\n  return x - x === 0;\n}\n```\n\nOr as another example, let's determine that sorting an array is stable and\n[idempotent](http://en.wikipedia.org/wiki/Idempotence), which is to say that\nsorting a sorted array shouldn't do anything. We could write:\n\n```javascript\nfunction (arr) {\n  var arrCopy = arr.slice();\n  return deepEqual(arrCopy.sort(), arr.sort().sort());\n}\n```\n\nThat's really it! The only thing special about this property function is that it\nis [pure](http://en.wikipedia.org/wiki/Pure_function), e.g. it relies only on\nthe provided arguments to determine its return value (no other reading\nor writing!).\n\nIf you can start to describe your program in terms of its properties, then\n`testcheck` can test them for you.\n\n\nGenerating test cases\n---------------------\n\nOnce we've defined some properties, we generate test cases for each properties\nby describing the types of values for each argument.\n\nFor testing our first property, we need numbers:\n\n```javascript\ngen.int\n```\n\nFor the second, we need arrays of numbers\n\n```javascript\ngen.array(gen.int)\n```\n\nThere are a wide variety of value generators, we've only scratched the surface.\nWe can generate random JSON with `gen.JSON`, pick amongst a set of values with\n`gen.returnOneOf`, nested arrays with ints `gen.nested(gen.array, gen.int)` and\nmuch more. You can even define your own generators with `gen.map`, `gen.bind`\nand `gen.sized`.\n\n\nChecking the properties\n-----------------------\n\nFinally, we check our properties using our test case generator (in this case,\nup to 1000 different tests before concluding).\n\n```javascript\nvar result = testcheck.check(\n  testcheck.property(\n    [gen.int],    // the arguments generator\n    function (x) {  // the property function to test\n      return x - x === 0;\n    }\n  ),\n  { times: 1000 }\n);\n```\n\n`check` runs through random cases looking for failure, and when it doesn't find\nany failures, it returns:\n\n```javascript\n{ result: true, 'num-tests': 1000, seed: 1406779597155 }\n```\n\n\nSmallest failing test\n---------------------\n\nLet's try another property: the sum of two integers is the same or larger than\neither of the integers alone.\n\n```javascript\ntestcheck.check(testcheck.property(\n  [gen.int, gen.int],\n  function (a, b) {\n    return a + b >= a && a + b >= b;\n  }\n));\n```\n\n`check` runs through random cases again. This time it found a failing case, so\nit returns:\n\n```javascript\n{ result: false,\n  'failing-size': 2,\n  'num-tests': 3,\n  fail: [ 2, -1 ],\n  shrunk:\n   { 'total-nodes-visited': 2,\n     depth: 1,\n     result: false,\n     smallest: [ 0, -1 ] } }\n```\n\nSomething is wrong. Either:\n\n  1. Our assumption is wrong (e.g. bug in our software).\n  2. The test code is wrong.\n  3. The generated test data is too broad.\n\nIn this case, our problem is that our generated data is too broad for our\nassumption. What's going on?\n\nWe can see that the `fail` case `2, -1` would in fact not be correct, but it\nmight not be immediately clear why. This is where test case shrinking comes in\nhandy. The `shrunk` key provides information about the shrinking process and\nmost importantly, the `smallest` values that still fail: `0, -1`.\n\nWe forgot about an edge case! If one of the integers is negative, then the sum\nwill not be larger. This shrunken test case illustrated this much better than\nthe original failing test did. Now we know that we can either improve our\nproperty or make the test data more specific:\n\n```javascript\ntestcheck.check(testcheck.property(\n  [gen.posInt, gen.posInt],\n  function (a, b) {\n    return a + b >= a && a + b >= b;\n  }\n));\n```\n\nWith our correction, our property passes all tests.\n\n\nThinking in random distributions\n--------------------------------\n\nIt's important to remember that your test is only as good as the data being\nprovided. While `testcheck` provides tools to generate random data, thinking\nabout what that data looks like may help you write better tests. Also, because\nthe data generated is random, a test may pass which simply failed to uncover\na corner case.\n\n> \"Testing shows the presence, not the absence of bugs\"\n>\n> â€” Dijkstra, 1969\n\n### Sampling Test Data\n\nVisualizing the data `check` generates may help diagnose the quality of a test.\nUse `sample` to get a look at what a generator produces:\n\n```javascript\ntestcheck.sample(gen.int)\n// [ 0, 0, 2, -1, 3, 5, -4, 0, 3, 5 ]\n```\n\n### The Size of Test Data\n\nTest data generators have an implicit `size` property, which could be used to\ndetermine the maximum value for a generated integer or the max length of a\ngenerated array. `testcheck` begins by generating small test cases and gradually\nincreases the size.\n\nSo if you wish to test very large numbers or extremely long arrays, running\n`check` the default 100 times with maxSize of 200, you may not get what\nyou expect.\n\n### Data relationships\n\nLet's test an assumption that should clearly be wrong: a string [split](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split)\nby another string always returns an array of length 1.\n\n```javascript\ntestcheck.check(testcheck.property(\n  [gen.notEmpty(gen.string), gen.notEmpty(gen.string)],\n  function (str, separator) {\n    return str.split(separator).length === 1;\n  }\n));\n```\n\nUnless you got lucky, you probably saw this check pass. This is because we're\ntesting for a relationship between these strings. If `separator` is not found\nin `str`, then this test passes. The second random string is very unlikely to\nbe found within the first random string.\n\nWe could change the test to be aware of this relationship such that the\n`separator` is always contained within the `str`.\n\n```javascript\ntestcheck.check(testcheck.property(\n  [gen.notEmpty(gen.string), gen.posInt, gen.strictPosInt],\n  function (str, start, length) {\n    var separator = str.substr(start % str.length, length);\n    return str.split(separator).length === 1;\n  }\n));\n```\n\nNow `separator` is a random substring of `str` and the test fails with the\nsmallest failing arguments: `'0', 0, 1`.\n\n\nContribution\n------------\n\nUse [Github issues](https://github.com/leebyron/testcheck-js/issues) for requests.\n\nPull requests actively welcomed. Learn how to [contribute](./CONTRIBUTING.md).\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/leebyron/testcheck-js.git"
  },
  "scripts": {
    "build": "./resources/build.sh",
    "test": "jasmine-node spec/"
  },
  "version": "0.1.4"
}
